name: Simple API CD Pipeline

on:
  # Trigger after CI workflow completes successfully
  workflow_run:
    workflows: ["Simple API CI Pipeline"]
    types:
      - completed
    branches: [ "main" ]
  # Allow manual trigger
  workflow_dispatch:

jobs:
  deploy-to-kubernetes:
    runs-on: self-hosted
    # Only run if CI was successful or manually triggered
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    
    defaults:
      run:
        shell: powershell

    steps:
      # ----------------------------------------------------
      # 1. Checkout Source Code
      # ----------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4

      # ----------------------------------------------------
      # 2. Verify Minikube Environment
      # ----------------------------------------------------
      - name: Verify Minikube Status
        run: |
          minikube status
          kubectl get nodes

      # ----------------------------------------------------
      # 3. Update Container Image Tag
      # ----------------------------------------------------
      - name: Update Deployment Image
        run: |
          (Get-Content k8s/deployment.yaml) -replace 'image: .*simple-api:.*', 'image: ${{ secrets.DOCKERHUB_USERNAME }}/simple-api:${{ github.sha }}' | Set-Content k8s/deployment.yaml
          Get-Content k8s/deployment.yaml | Select-String "image:"

      # ----------------------------------------------------
      # 4. Deploy Application to Kubernetes
      # ----------------------------------------------------
      - name: Create Namespace
        run: kubectl apply -f k8s/namespace.yaml

      - name: Apply ConfigMap
        run: kubectl apply -f k8s/configmap.yaml

      - name: Deploy Application
        run: kubectl apply -f k8s/deployment.yaml

      - name: Apply Service
        run: kubectl apply -f k8s/service.yaml

      # ----------------------------------------------------
      # 5. Monitor Deployment Rollout
      # ----------------------------------------------------
      - name: Wait for Deployment to be Ready
        run: kubectl rollout status deployment/simple-api-deployment -n simple-api --timeout=300s

      # ----------------------------------------------------
      # 6. Verify Deployment Health
      # ----------------------------------------------------
      - name: Verify Deployment
        run: |
          Write-Output "=== Deployment Status ==="
          kubectl get deployment -n simple-api
          Write-Output ""
          Write-Output "=== Pod Status ==="
          kubectl get pods -n simple-api
          Write-Output ""
          Write-Output "=== Service Status ==="
          kubectl get svc -n simple-api

      # ----------------------------------------------------
      # 7. Application Functionality Test (Smoke Test)
      # ----------------------------------------------------
      - name: Run Smoke Test
        run: |
          Write-Output "Testing application functionality..."

          # Get a running pod name
          $POD_NAME = kubectl get pods -n simple-api -l app=simple-api -o jsonpath='{.items[0].metadata.name}'
          if (-not $POD_NAME) {
            Write-Output "ERROR: No running pods found!"
            kubectl get pods -n simple-api
            exit 1
          }
          Write-Output "Testing with pod: $POD_NAME"

          # Test the main API endpoint using kubectl exec
          Write-Output "Testing API endpoint..."
          $apiTest = kubectl exec -n simple-api $POD_NAME -- curl -f -s http://simple-api-service/hello
          if ($LASTEXITCODE -ne 0 -or $apiTest -notmatch "Hello World") {
            Write-Output "API test failed. Expected 'Hello World' in response, got: $apiTest"
            kubectl logs -n simple-api $POD_NAME --tail=20
            exit 1
          }

          # Test actuator health endpoint
          Write-Output "Testing health endpoint..."
          $healthTest = kubectl exec -n simple-api $POD_NAME -- curl -f -s http://simple-api-service/actuator/health
          if ($LASTEXITCODE -ne 0) {
            Write-Output "Health check failed. Curl exit code: $LASTEXITCODE"
            kubectl logs -n simple-api $POD_NAME --tail=20
            exit 1
          }

          try {
            $HEALTH_RESPONSE = $healthTest | ConvertFrom-Json
            if ($HEALTH_RESPONSE.status -ne "UP") {
              Write-Output "Health check failed. Status: $($HEALTH_RESPONSE.status)"
              exit 1
            }
          } catch {
            Write-Output "Health check response parsing failed: $healthTest"
            exit 1
          }

          # Check if pods are running - using simpler approach
          $READY_COUNT = kubectl get pods -n simple-api -l app=simple-api --field-selector=status.phase=Running -o json | ConvertFrom-Json | Select-Object -ExpandProperty items | Where-Object { $_.status.conditions | Where-Object { $_.type -eq "Ready" -and $_.status -eq "True" } } | Measure-Object | Select-Object -ExpandProperty Count
          if ($READY_COUNT -lt 1) {
            Write-Output "ERROR: No pods are ready!"
            kubectl describe pods -n simple-api
            kubectl logs -l app=simple-api -n simple-api --tail=50
            exit 1
          }
          Write-Output "SUCCESS: $READY_COUNT pod(s) are ready and running"

      # ----------------------------------------------------
      # 8. Basic Security Assessment (DAST Simulation)
      # ----------------------------------------------------
      - name: Perform Basic Security Assessment
        run: |
          Write-Output "Performing basic security assessment..."

          # Get a running pod name
          $POD_NAME = kubectl get pods -n simple-api -l app=simple-api -o jsonpath='{.items[0].metadata.name}'
          if (-not $POD_NAME) {
            Write-Output "ERROR: No running pods found for security assessment!"
            exit 1
          }

          # Test for potential information disclosure using kubectl exec
          Write-Output "Testing for information disclosure..."
          $errorResponse = kubectl exec -n simple-api $POD_NAME -- curl -s http://simple-api-service/nonexistent-endpoint
          if ($errorResponse -match "stacktrace|exception|error|Exception|Error") {
            Write-Output "Warning: Potential information disclosure in error responses."
          } else {
            Write-Output "Info: Error responses appear sanitized."
          }

          Write-Output "Basic security assessment completed."

      # ----------------------------------------------------
      # 9. Deployment Summary
      # ----------------------------------------------------
      - name: Generate Deployment Report
        run: |
          Write-Output "Deployment Summary:"
          Write-Output "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
          Write-Output "Commit SHA: ${{ github.sha }}"
          Write-Output "Environment: Minikube/Kubernetes"
          Write-Output ""

          Write-Output "Resource Status:"
          kubectl get all -n simple-api
          Write-Output ""

          Write-Output "Service Accessibility:"
          Write-Output "Service Type: ClusterIP (internal access only)"
          Write-Output "Port: 80"
          Write-Output "Note: Accessible via kubectl port-forward or Ingress"
          Write-Output ""

          Write-Output "Health Check Results:"
          try {
            $HEALTH = Invoke-RestMethod -Uri "$SERVICE_URL/actuator/health"
            $HEALTH | ConvertTo-Json -Depth 10
          } catch {
            Write-Output "Could not retrieve health information"
          }
          Write-Output ""

          Write-Output "Deployment completed successfully."
